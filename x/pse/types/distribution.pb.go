// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tx/pse/v1/distribution.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClearingAccountMapping defines the mapping between a clearing account (module account) and its recipients (sub account multisig wallets).
// This mapping can be modified via governance proposals.
// Each clearing account must have at least one recipient address.
// During distribution, the allocated amount is split equally among all recipients.
type ClearingAccountMapping struct {
	// clearing_account is the name of the clearing account holding the tokens to be distributed.
	ClearingAccount string `protobuf:"bytes,1,opt,name=clearing_account,json=clearingAccount,proto3" json:"clearing_account,omitempty" yaml:"clearing_account"`
	// recipient_addresses is the list of multisig wallet addresses that will receive the token distributions.
	// Must have at least one address. Distribution amount is split equally among all recipients.
	RecipientAddresses []string `protobuf:"bytes,2,rep,name=recipient_addresses,json=recipientAddresses,proto3" json:"recipient_addresses,omitempty" yaml:"recipient_addresses"`
}

func (m *ClearingAccountMapping) Reset()         { *m = ClearingAccountMapping{} }
func (m *ClearingAccountMapping) String() string { return proto.CompactTextString(m) }
func (*ClearingAccountMapping) ProtoMessage()    {}
func (*ClearingAccountMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{0}
}
func (m *ClearingAccountMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearingAccountMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearingAccountMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearingAccountMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearingAccountMapping.Merge(m, src)
}
func (m *ClearingAccountMapping) XXX_Size() int {
	return m.Size()
}
func (m *ClearingAccountMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearingAccountMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ClearingAccountMapping proto.InternalMessageInfo

func (m *ClearingAccountMapping) GetClearingAccount() string {
	if m != nil {
		return m.ClearingAccount
	}
	return ""
}

func (m *ClearingAccountMapping) GetRecipientAddresses() []string {
	if m != nil {
		return m.RecipientAddresses
	}
	return nil
}

// ClearingAccountAllocation defines the amount to be allocated from a specific clearing account (module account).
type ClearingAccountAllocation struct {
	// clearing_account is the name of the clearing account (module account).
	ClearingAccount string `protobuf:"bytes,1,opt,name=clearing_account,json=clearingAccount,proto3" json:"clearing_account,omitempty" yaml:"clearing_account"`
	// amount is the number of tokens to allocate from this clearing account.
	// This amount is for the allocation denom (see AllocationDenom constant).
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount" yaml:"amount"`
}

func (m *ClearingAccountAllocation) Reset()         { *m = ClearingAccountAllocation{} }
func (m *ClearingAccountAllocation) String() string { return proto.CompactTextString(m) }
func (*ClearingAccountAllocation) ProtoMessage()    {}
func (*ClearingAccountAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{1}
}
func (m *ClearingAccountAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearingAccountAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearingAccountAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearingAccountAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearingAccountAllocation.Merge(m, src)
}
func (m *ClearingAccountAllocation) XXX_Size() int {
	return m.Size()
}
func (m *ClearingAccountAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearingAccountAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_ClearingAccountAllocation proto.InternalMessageInfo

func (m *ClearingAccountAllocation) GetClearingAccount() string {
	if m != nil {
		return m.ClearingAccount
	}
	return ""
}

// ScheduledDistribution defines a single allocation event at a specific timestamp.
// Multiple clearing accounts can allocate tokens at the same time.
type ScheduledDistribution struct {
	// timestamp is when this allocation should occur (Unix timestamp in seconds).
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty" yaml:"timestamp"`
	// allocations is the list of amounts to allocate from each clearing account at this time.
	Allocations []ClearingAccountAllocation `protobuf:"bytes,2,rep,name=allocations,proto3" json:"allocations" yaml:"allocations"`
}

func (m *ScheduledDistribution) Reset()         { *m = ScheduledDistribution{} }
func (m *ScheduledDistribution) String() string { return proto.CompactTextString(m) }
func (*ScheduledDistribution) ProtoMessage()    {}
func (*ScheduledDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{2}
}
func (m *ScheduledDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduledDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduledDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduledDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduledDistribution.Merge(m, src)
}
func (m *ScheduledDistribution) XXX_Size() int {
	return m.Size()
}
func (m *ScheduledDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduledDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduledDistribution proto.InternalMessageInfo

func (m *ScheduledDistribution) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ScheduledDistribution) GetAllocations() []ClearingAccountAllocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

// CommunityDistributionJob tracks an in-progress community distribution batch job.
type CommunityDistributionJob struct {
	// scheduled_at is the Unix timestamp of the distribution period being paid out.
	ScheduledAt uint64 `protobuf:"varint,1,opt,name=scheduled_at,json=scheduledAt,proto3" json:"scheduled_at,omitempty" yaml:"scheduled_at"`
	// total_amount is the total amount to distribute for this period.
	TotalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_amount,json=totalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount" yaml:"total_amount"`
	// total_score is the sum of all eligible delegator scores at snapshot time.
	TotalScore cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_score,json=totalScore,proto3,customtype=cosmossdk.io/math.Int" json:"total_score" yaml:"total_score"`
	// leftover tracks undistributed amount to be sent to the community pool at completion.
	Leftover cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=leftover,proto3,customtype=cosmossdk.io/math.Int" json:"leftover" yaml:"leftover"`
	// next_address is the exclusive cursor for the next delegator to process.
	// Empty means start from the beginning of the address-ordered map.
	NextAddress string `protobuf:"bytes,5,opt,name=next_address,json=nextAddress,proto3" json:"next_address,omitempty" yaml:"next_address"`
	// total_entries is the number of delegators included in this snapshot.
	TotalEntries uint64 `protobuf:"varint,6,opt,name=total_entries,json=totalEntries,proto3" json:"total_entries,omitempty" yaml:"total_entries"`
	// processed_entries is the number of delegators already processed.
	ProcessedEntries uint64 `protobuf:"varint,7,opt,name=processed_entries,json=processedEntries,proto3" json:"processed_entries,omitempty" yaml:"processed_entries"`
}

func (m *CommunityDistributionJob) Reset()         { *m = CommunityDistributionJob{} }
func (m *CommunityDistributionJob) String() string { return proto.CompactTextString(m) }
func (*CommunityDistributionJob) ProtoMessage()    {}
func (*CommunityDistributionJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{3}
}
func (m *CommunityDistributionJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommunityDistributionJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommunityDistributionJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommunityDistributionJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommunityDistributionJob.Merge(m, src)
}
func (m *CommunityDistributionJob) XXX_Size() int {
	return m.Size()
}
func (m *CommunityDistributionJob) XXX_DiscardUnknown() {
	xxx_messageInfo_CommunityDistributionJob.DiscardUnknown(m)
}

var xxx_messageInfo_CommunityDistributionJob proto.InternalMessageInfo

func (m *CommunityDistributionJob) GetScheduledAt() uint64 {
	if m != nil {
		return m.ScheduledAt
	}
	return 0
}

func (m *CommunityDistributionJob) GetNextAddress() string {
	if m != nil {
		return m.NextAddress
	}
	return ""
}

func (m *CommunityDistributionJob) GetTotalEntries() uint64 {
	if m != nil {
		return m.TotalEntries
	}
	return 0
}

func (m *CommunityDistributionJob) GetProcessedEntries() uint64 {
	if m != nil {
		return m.ProcessedEntries
	}
	return 0
}

// CommunityDistributionEntry stores a delegator score for a snapshot period.
type CommunityDistributionEntry struct {
	DelegatorAddress string                `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty" yaml:"delegator_address"`
	Score            cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=score,proto3,customtype=cosmossdk.io/math.Int" json:"score" yaml:"score"`
}

func (m *CommunityDistributionEntry) Reset()         { *m = CommunityDistributionEntry{} }
func (m *CommunityDistributionEntry) String() string { return proto.CompactTextString(m) }
func (*CommunityDistributionEntry) ProtoMessage()    {}
func (*CommunityDistributionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{4}
}
func (m *CommunityDistributionEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommunityDistributionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommunityDistributionEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommunityDistributionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommunityDistributionEntry.Merge(m, src)
}
func (m *CommunityDistributionEntry) XXX_Size() int {
	return m.Size()
}
func (m *CommunityDistributionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CommunityDistributionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CommunityDistributionEntry proto.InternalMessageInfo

func (m *CommunityDistributionEntry) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*ClearingAccountMapping)(nil), "tx.pse.v1.ClearingAccountMapping")
	proto.RegisterType((*ClearingAccountAllocation)(nil), "tx.pse.v1.ClearingAccountAllocation")
	proto.RegisterType((*ScheduledDistribution)(nil), "tx.pse.v1.ScheduledDistribution")
	proto.RegisterType((*CommunityDistributionJob)(nil), "tx.pse.v1.CommunityDistributionJob")
	proto.RegisterType((*CommunityDistributionEntry)(nil), "tx.pse.v1.CommunityDistributionEntry")
}

func init() { proto.RegisterFile("tx/pse/v1/distribution.proto", fileDescriptor_a549fe743b42ab69) }

var fileDescriptor_a549fe743b42ab69 = []byte{
	// 695 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0x8e, 0xf9, 0xbb, 0x37, 0x93, 0x20, 0xc2, 0x10, 0x2e, 0x26, 0x17, 0xc5, 0xc8, 0xea, 0x82,
	0x4d, 0x6c, 0x41, 0x2b, 0x16, 0xf4, 0x47, 0x4a, 0xe8, 0x8f, 0xa8, 0xd4, 0x45, 0x4d, 0x57, 0x6c,
	0xa2, 0x89, 0x3d, 0x75, 0x46, 0xd8, 0x1e, 0xcb, 0x33, 0x89, 0x92, 0x3e, 0x45, 0xdf, 0xa4, 0x9b,
	0x6e, 0xfa, 0x06, 0x74, 0x87, 0x58, 0x55, 0xad, 0x64, 0x55, 0xf0, 0x06, 0x7e, 0x82, 0xca, 0x33,
	0x8e, 0x63, 0x02, 0x28, 0x9b, 0xee, 0x32, 0xf3, 0x7d, 0xe7, 0x3b, 0xe7, 0x7c, 0x73, 0x4e, 0x0c,
	0x76, 0xf8, 0xc8, 0x0c, 0x19, 0x36, 0x87, 0xfb, 0xa6, 0x43, 0x18, 0x8f, 0x48, 0x6f, 0xc0, 0x09,
	0x0d, 0x8c, 0x30, 0xa2, 0x9c, 0xc2, 0x32, 0x1f, 0x19, 0x21, 0xc3, 0xc6, 0x70, 0xbf, 0x51, 0x77,
	0xa9, 0x4b, 0xc5, 0xad, 0x99, 0xfe, 0x92, 0x84, 0xc6, 0xb6, 0x4d, 0x99, 0x4f, 0x59, 0x57, 0x02,
	0xf2, 0x20, 0x21, 0xfd, 0xbb, 0x02, 0xfe, 0x3b, 0xf6, 0x30, 0x8a, 0x48, 0xe0, 0xb6, 0x6d, 0x9b,
	0x0e, 0x02, 0xfe, 0x0e, 0x85, 0x21, 0x09, 0x5c, 0xf8, 0x1a, 0xd4, 0xec, 0x0c, 0xe9, 0x22, 0x09,
	0xa9, 0xca, 0xae, 0xb2, 0x57, 0xee, 0xfc, 0x9f, 0xc4, 0xda, 0xd6, 0x18, 0xf9, 0xde, 0x91, 0x3e,
	0xcb, 0xd0, 0xad, 0x35, 0xfb, 0xb6, 0x1c, 0x74, 0xc1, 0x46, 0x84, 0x6d, 0x12, 0x12, 0x1c, 0xf0,
	0x2e, 0x72, 0x9c, 0x08, 0x33, 0x86, 0x99, 0xba, 0xb0, 0xbb, 0xb8, 0x57, 0xee, 0x1c, 0x26, 0xb1,
	0xd6, 0x90, 0x52, 0xf7, 0x90, 0xf4, 0xab, 0xaf, 0xad, 0x7a, 0x56, 0x6f, 0x5b, 0x5e, 0x9e, 0xf2,
	0x54, 0xdb, 0x82, 0x39, 0xbb, 0x9d, 0x93, 0xbf, 0x29, 0x60, 0x7b, 0xa6, 0x97, 0xb6, 0xe7, 0x51,
	0x1b, 0xa5, 0x5e, 0xfd, 0xb5, 0x76, 0x3e, 0x80, 0x15, 0xe4, 0x8b, 0xe8, 0x05, 0x11, 0xfd, 0xec,
	0x22, 0xd6, 0x4a, 0x3f, 0x63, 0x6d, 0x53, 0xd6, 0xc9, 0x9c, 0x73, 0x83, 0x50, 0xd3, 0x47, 0xbc,
	0x6f, 0x9c, 0x04, 0x3c, 0x89, 0xb5, 0x55, 0x29, 0x2d, 0x83, 0xd2, 0x8e, 0x40, 0xd6, 0xd1, 0x49,
	0xc0, 0xad, 0x4c, 0x4b, 0xff, 0xa2, 0x80, 0xcd, 0x53, 0xbb, 0x8f, 0x9d, 0x81, 0x87, 0x9d, 0x97,
	0x85, 0x37, 0x86, 0x07, 0xa0, 0xcc, 0x89, 0x8f, 0x19, 0x47, 0x7e, 0x28, 0x0a, 0x5e, 0xea, 0xd4,
	0x93, 0x58, 0xab, 0x49, 0xd5, 0x1c, 0xd2, 0xad, 0x29, 0x0d, 0xf6, 0x40, 0x05, 0xe5, 0x9d, 0x4b,
	0xab, 0x2b, 0x07, 0x8f, 0x8c, 0x7c, 0x4e, 0x8c, 0x07, 0x6d, 0xea, 0x34, 0xd2, 0x76, 0x92, 0x58,
	0x83, 0x59, 0xd5, 0x53, 0x19, 0xdd, 0x2a, 0x8a, 0xea, 0xbf, 0x96, 0x80, 0x7a, 0x4c, 0x7d, 0x7f,
	0x10, 0x10, 0x3e, 0x2e, 0x56, 0xfc, 0x96, 0xf6, 0xe0, 0x11, 0xa8, 0xb2, 0x49, 0x37, 0x5d, 0xc4,
	0xb3, 0xba, 0xb7, 0x92, 0x58, 0xdb, 0x90, 0xba, 0x45, 0x54, 0xb7, 0x2a, 0xf9, 0xb1, 0xcd, 0x21,
	0x06, 0x55, 0x4e, 0x39, 0xf2, 0xba, 0xb7, 0x6c, 0xee, 0xcc, 0xb3, 0x39, 0x13, 0x2e, 0x86, 0xce,
	0x9a, 0x5d, 0x11, 0x60, 0x5b, 0x60, 0xa9, 0x47, 0x92, 0xcb, 0x6c, 0x1a, 0x61, 0x75, 0x51, 0x64,
	0x69, 0xcf, 0xcb, 0x02, 0x8b, 0x59, 0x44, 0xe4, 0x6c, 0x12, 0x20, 0xb0, 0xd3, 0x14, 0x82, 0x67,
	0xe0, 0x5f, 0x0f, 0x7f, 0xe4, 0x74, 0x88, 0x23, 0x75, 0x49, 0x24, 0x78, 0x31, 0x2f, 0xc1, 0x9a,
	0x4c, 0x30, 0x09, 0x9b, 0x55, 0xcf, 0xf5, 0xa0, 0x05, 0xaa, 0x01, 0x1e, 0xe5, 0xcb, 0xa2, 0x2e,
	0x0b, 0x7d, 0x73, 0xea, 0x44, 0x11, 0x7d, 0x78, 0x91, 0x2a, 0x29, 0x2d, 0xbb, 0x82, 0xcf, 0xc1,
	0xaa, 0xec, 0x0c, 0x07, 0x3c, 0x22, 0x98, 0xa9, 0x2b, 0xe2, 0xdd, 0xd4, 0x24, 0xd6, 0xea, 0xc5,
	0xc6, 0x33, 0x58, 0xb7, 0xe4, 0x4b, 0xbd, 0x92, 0x47, 0x78, 0x02, 0xd6, 0xc3, 0x88, 0xda, 0xe9,
	0x36, 0x3a, 0xb9, 0xc4, 0x3f, 0x42, 0x62, 0x27, 0x89, 0x35, 0x55, 0x4a, 0xdc, 0xa1, 0xe8, 0x56,
	0x2d, 0xbf, 0xcb, 0xa4, 0xf4, 0x2b, 0x05, 0x34, 0xee, 0x9d, 0xae, 0x94, 0x30, 0x86, 0x08, 0xac,
	0x3b, 0xd8, 0xc3, 0x2e, 0xe2, 0x34, 0xca, 0x1d, 0x90, 0xdb, 0xfc, 0x64, 0x9a, 0xe9, 0x0e, 0xe5,
	0x61, 0x1b, 0x6a, 0x39, 0x77, 0xe2, 0xc5, 0x7b, 0xb0, 0x2c, 0x27, 0x43, 0xce, 0xdf, 0xd3, 0x79,
	0x0f, 0x57, 0x9d, 0x0c, 0xf6, 0x3d, 0x33, 0x21, 0x95, 0x3a, 0x6f, 0x2e, 0xae, 0x9b, 0xca, 0xe5,
	0x75, 0x53, 0xf9, 0x7d, 0xdd, 0x54, 0x3e, 0xdf, 0x34, 0x4b, 0x97, 0x37, 0xcd, 0xd2, 0x8f, 0x9b,
	0x66, 0xe9, 0xac, 0xe5, 0x12, 0xde, 0x1f, 0xf4, 0x0c, 0x9b, 0xfa, 0x26, 0xa7, 0xe7, 0x38, 0x20,
	0x9f, 0x70, 0x6b, 0x64, 0xf2, 0x51, 0xcb, 0xee, 0x23, 0x12, 0x98, 0xc3, 0x43, 0x53, 0x7e, 0x01,
	0xf8, 0x38, 0xc4, 0xac, 0xb7, 0x22, 0xfe, 0xbc, 0x1f, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x8b,
	0xf8, 0xd5, 0x8c, 0x18, 0x06, 0x00, 0x00,
}

func (m *ClearingAccountMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearingAccountMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearingAccountMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecipientAddresses) > 0 {
		for iNdEx := len(m.RecipientAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientAddresses[iNdEx])
			copy(dAtA[i:], m.RecipientAddresses[iNdEx])
			i = encodeVarintDistribution(dAtA, i, uint64(len(m.RecipientAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClearingAccount) > 0 {
		i -= len(m.ClearingAccount)
		copy(dAtA[i:], m.ClearingAccount)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.ClearingAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearingAccountAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearingAccountAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearingAccountAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClearingAccount) > 0 {
		i -= len(m.ClearingAccount)
		copy(dAtA[i:], m.ClearingAccount)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.ClearingAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduledDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduledDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduledDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDistribution(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintDistribution(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommunityDistributionJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityDistributionJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommunityDistributionJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProcessedEntries != 0 {
		i = encodeVarintDistribution(dAtA, i, uint64(m.ProcessedEntries))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalEntries != 0 {
		i = encodeVarintDistribution(dAtA, i, uint64(m.TotalEntries))
		i--
		dAtA[i] = 0x30
	}
	if len(m.NextAddress) > 0 {
		i -= len(m.NextAddress)
		copy(dAtA[i:], m.NextAddress)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.NextAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Leftover.Size()
		i -= size
		if _, err := m.Leftover.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalScore.Size()
		i -= size
		if _, err := m.TotalScore.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ScheduledAt != 0 {
		i = encodeVarintDistribution(dAtA, i, uint64(m.ScheduledAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommunityDistributionEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityDistributionEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommunityDistributionEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Score.Size()
		i -= size
		if _, err := m.Score.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDistribution(dAtA []byte, offset int, v uint64) int {
	offset -= sovDistribution(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClearingAccountMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClearingAccount)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	if len(m.RecipientAddresses) > 0 {
		for _, s := range m.RecipientAddresses {
			l = len(s)
			n += 1 + l + sovDistribution(uint64(l))
		}
	}
	return n
}

func (m *ClearingAccountAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClearingAccount)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovDistribution(uint64(l))
	return n
}

func (m *ScheduledDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovDistribution(uint64(m.Timestamp))
	}
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovDistribution(uint64(l))
		}
	}
	return n
}

func (m *CommunityDistributionJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScheduledAt != 0 {
		n += 1 + sovDistribution(uint64(m.ScheduledAt))
	}
	l = m.TotalAmount.Size()
	n += 1 + l + sovDistribution(uint64(l))
	l = m.TotalScore.Size()
	n += 1 + l + sovDistribution(uint64(l))
	l = m.Leftover.Size()
	n += 1 + l + sovDistribution(uint64(l))
	l = len(m.NextAddress)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	if m.TotalEntries != 0 {
		n += 1 + sovDistribution(uint64(m.TotalEntries))
	}
	if m.ProcessedEntries != 0 {
		n += 1 + sovDistribution(uint64(m.ProcessedEntries))
	}
	return n
}

func (m *CommunityDistributionEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	l = m.Score.Size()
	n += 1 + l + sovDistribution(uint64(l))
	return n
}

func sovDistribution(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDistribution(x uint64) (n int) {
	return sovDistribution(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClearingAccountMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearingAccountMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearingAccountMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientAddresses = append(m.RecipientAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearingAccountAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearingAccountAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearingAccountAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduledDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduledDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduledDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, ClearingAccountAllocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunityDistributionJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityDistributionJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityDistributionJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledAt", wireType)
			}
			m.ScheduledAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduledAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leftover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Leftover.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEntries", wireType)
			}
			m.TotalEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalEntries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedEntries", wireType)
			}
			m.ProcessedEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedEntries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunityDistributionEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityDistributionEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityDistributionEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Score.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDistribution(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDistribution
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDistribution
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDistribution
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDistribution        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDistribution          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDistribution = fmt.Errorf("proto: unexpected end of group")
)
