// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tx/pse/v1/distribution.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClearingAccountMapping defines the mapping between a clearing account (module account) and its recipients (sub account multisig wallets).
// This mapping can be modified via governance proposals.
// Each clearing account must have at least one recipient address.
// During distribution, the allocated amount is split equally among all recipients.
type ClearingAccountMapping struct {
	// clearing_account is the name of the clearing account holding the tokens to be distributed.
	ClearingAccount string `protobuf:"bytes,1,opt,name=clearing_account,json=clearingAccount,proto3" json:"clearing_account,omitempty" yaml:"clearing_account"`
	// recipient_addresses is the list of multisig wallet addresses that will receive the token distributions.
	// Must have at least one address. Distribution amount is split equally among all recipients.
	RecipientAddresses []string `protobuf:"bytes,2,rep,name=recipient_addresses,json=recipientAddresses,proto3" json:"recipient_addresses,omitempty" yaml:"recipient_addresses"`
}

func (m *ClearingAccountMapping) Reset()         { *m = ClearingAccountMapping{} }
func (m *ClearingAccountMapping) String() string { return proto.CompactTextString(m) }
func (*ClearingAccountMapping) ProtoMessage()    {}
func (*ClearingAccountMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{0}
}
func (m *ClearingAccountMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearingAccountMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearingAccountMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearingAccountMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearingAccountMapping.Merge(m, src)
}
func (m *ClearingAccountMapping) XXX_Size() int {
	return m.Size()
}
func (m *ClearingAccountMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearingAccountMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ClearingAccountMapping proto.InternalMessageInfo

func (m *ClearingAccountMapping) GetClearingAccount() string {
	if m != nil {
		return m.ClearingAccount
	}
	return ""
}

func (m *ClearingAccountMapping) GetRecipientAddresses() []string {
	if m != nil {
		return m.RecipientAddresses
	}
	return nil
}

// ClearingAccountAllocation defines the amount to be allocated from a specific clearing account (module account).
type ClearingAccountAllocation struct {
	// clearing_account is the name of the clearing account (module account).
	ClearingAccount string `protobuf:"bytes,1,opt,name=clearing_account,json=clearingAccount,proto3" json:"clearing_account,omitempty" yaml:"clearing_account"`
	// amount is the number of tokens to allocate from this clearing account.
	// This amount is for the allocation denom (see AllocationDenom constant).
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount" yaml:"amount"`
}

func (m *ClearingAccountAllocation) Reset()         { *m = ClearingAccountAllocation{} }
func (m *ClearingAccountAllocation) String() string { return proto.CompactTextString(m) }
func (*ClearingAccountAllocation) ProtoMessage()    {}
func (*ClearingAccountAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{1}
}
func (m *ClearingAccountAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearingAccountAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearingAccountAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearingAccountAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearingAccountAllocation.Merge(m, src)
}
func (m *ClearingAccountAllocation) XXX_Size() int {
	return m.Size()
}
func (m *ClearingAccountAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearingAccountAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_ClearingAccountAllocation proto.InternalMessageInfo

func (m *ClearingAccountAllocation) GetClearingAccount() string {
	if m != nil {
		return m.ClearingAccount
	}
	return ""
}

// ScheduledDistribution defines a single allocation event at a specific timestamp.
// Multiple clearing accounts can allocate tokens at the same time.
type ScheduledDistribution struct {
	// timestamp is when this allocation should occur (Unix timestamp in seconds).
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty" yaml:"timestamp"`
	// allocations is the list of amounts to allocate from each clearing account at this time.
	Allocations []ClearingAccountAllocation `protobuf:"bytes,2,rep,name=allocations,proto3" json:"allocations" yaml:"allocations"`
}

func (m *ScheduledDistribution) Reset()         { *m = ScheduledDistribution{} }
func (m *ScheduledDistribution) String() string { return proto.CompactTextString(m) }
func (*ScheduledDistribution) ProtoMessage()    {}
func (*ScheduledDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a549fe743b42ab69, []int{2}
}
func (m *ScheduledDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduledDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduledDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduledDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduledDistribution.Merge(m, src)
}
func (m *ScheduledDistribution) XXX_Size() int {
	return m.Size()
}
func (m *ScheduledDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduledDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduledDistribution proto.InternalMessageInfo

func (m *ScheduledDistribution) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ScheduledDistribution) GetAllocations() []ClearingAccountAllocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

func init() {
	proto.RegisterType((*ClearingAccountMapping)(nil), "tx.pse.v1.ClearingAccountMapping")
	proto.RegisterType((*ClearingAccountAllocation)(nil), "tx.pse.v1.ClearingAccountAllocation")
	proto.RegisterType((*ScheduledDistribution)(nil), "tx.pse.v1.ScheduledDistribution")
}

func init() { proto.RegisterFile("tx/pse/v1/distribution.proto", fileDescriptor_a549fe743b42ab69) }

var fileDescriptor_a549fe743b42ab69 = []byte{
	// 442 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x92, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0x73, 0x05, 0x55, 0xca, 0x55, 0x88, 0xca, 0xa4, 0xd0, 0x06, 0x64, 0x57, 0x16, 0x43,
	0x97, 0xdc, 0xa9, 0x45, 0xea, 0x80, 0x58, 0x62, 0x10, 0xa8, 0x03, 0x8b, 0xcb, 0xc4, 0x12, 0x5d,
	0xce, 0x27, 0xe7, 0x54, 0xfb, 0xee, 0xe4, 0x7b, 0x89, 0x52, 0x3e, 0x05, 0xdf, 0x84, 0x85, 0x85,
	0x6f, 0x50, 0xb6, 0x8a, 0x09, 0x31, 0x58, 0x28, 0xf9, 0x06, 0xfe, 0x04, 0xc8, 0x3e, 0xcb, 0x2d,
	0x11, 0x6c, 0xdd, 0xec, 0xf7, 0xff, 0xbf, 0x9f, 0xde, 0xff, 0xdd, 0xc3, 0xcf, 0x60, 0x49, 0x8d,
	0x15, 0x74, 0x71, 0x4c, 0x13, 0x69, 0xa1, 0x90, 0xd3, 0x39, 0x48, 0xad, 0x88, 0x29, 0x34, 0x68,
	0xaf, 0x0f, 0x4b, 0x62, 0xac, 0x20, 0x8b, 0xe3, 0xe1, 0x20, 0xd5, 0xa9, 0x6e, 0xaa, 0xb4, 0xfe,
	0x72, 0x86, 0xe1, 0x01, 0xd7, 0x36, 0xd7, 0x76, 0xe2, 0x04, 0xf7, 0xe3, 0xa4, 0xf0, 0x3b, 0xc2,
	0x8f, 0x5f, 0x67, 0x82, 0x15, 0x52, 0xa5, 0x63, 0xce, 0xf5, 0x5c, 0xc1, 0x7b, 0x66, 0x8c, 0x54,
	0xa9, 0xf7, 0x16, 0xef, 0xf2, 0x56, 0x99, 0x30, 0x27, 0xed, 0xa3, 0x43, 0x74, 0xd4, 0x8f, 0x9e,
	0x56, 0x65, 0xf0, 0xe4, 0x92, 0xe5, 0xd9, 0xcb, 0x70, 0xd3, 0x11, 0xc6, 0x0f, 0xf9, 0xdf, 0x38,
	0x2f, 0xc5, 0x8f, 0x0a, 0xc1, 0xa5, 0x91, 0x42, 0xc1, 0x84, 0x25, 0x49, 0x21, 0xac, 0x15, 0x76,
	0x7f, 0xeb, 0xf0, 0xde, 0x51, 0x3f, 0x3a, 0xad, 0xca, 0x60, 0xe8, 0x50, 0xff, 0x30, 0x85, 0x3f,
	0xbe, 0x8e, 0x06, 0xed, 0xbc, 0x63, 0x57, 0x3c, 0x87, 0x9a, 0x1d, 0x7b, 0x9d, 0x7b, 0xdc, 0x99,
	0xbf, 0x21, 0x7c, 0xb0, 0x91, 0x65, 0x9c, 0x65, 0x9a, 0xb3, 0x7a, 0x57, 0x77, 0x16, 0xe7, 0x03,
	0xde, 0x66, 0x79, 0xd3, 0xbd, 0xd5, 0x74, 0xbf, 0xba, 0x2a, 0x83, 0xde, 0xaf, 0x32, 0xd8, 0x73,
	0x73, 0xda, 0xe4, 0x82, 0x48, 0x4d, 0x73, 0x06, 0x33, 0x72, 0xa6, 0xa0, 0x2a, 0x83, 0x07, 0x0e,
	0xed, 0x9a, 0xea, 0x44, 0xb8, 0x4d, 0x74, 0xa6, 0x20, 0x6e, 0x59, 0xe1, 0x17, 0x84, 0xf7, 0xce,
	0xf9, 0x4c, 0x24, 0xf3, 0x4c, 0x24, 0x6f, 0x6e, 0xbd, 0xb1, 0x77, 0x82, 0xfb, 0x20, 0x73, 0x61,
	0x81, 0xe5, 0xa6, 0x19, 0xf8, 0x7e, 0x34, 0xa8, 0xca, 0x60, 0xd7, 0x51, 0x3b, 0x29, 0x8c, 0x6f,
	0x6c, 0xde, 0x14, 0xef, 0xb0, 0x2e, 0xb9, 0x5b, 0xf5, 0xce, 0xc9, 0x73, 0xd2, 0xdd, 0x09, 0xf9,
	0xef, 0x9a, 0xa2, 0x61, 0x1d, 0xa7, 0x2a, 0x03, 0xaf, 0x9d, 0xfa, 0x06, 0x13, 0xc6, 0xb7, 0xa1,
	0xd1, 0xbb, 0xab, 0x95, 0x8f, 0xae, 0x57, 0x3e, 0xfa, 0xbd, 0xf2, 0xd1, 0xe7, 0xb5, 0xdf, 0xbb,
	0x5e, 0xfb, 0xbd, 0x9f, 0x6b, 0xbf, 0xf7, 0x71, 0x94, 0x4a, 0x98, 0xcd, 0xa7, 0x84, 0xeb, 0x9c,
	0x82, 0xbe, 0x10, 0x4a, 0x7e, 0x12, 0xa3, 0x25, 0x85, 0xe5, 0x88, 0xcf, 0x98, 0x54, 0x74, 0x71,
	0x4a, 0xdd, 0x39, 0xc3, 0xa5, 0x11, 0x76, 0xba, 0xdd, 0x5c, 0xe2, 0x8b, 0x3f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xc6, 0xb1, 0x54, 0x72, 0xe5, 0x02, 0x00, 0x00,
}

func (m *ClearingAccountMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearingAccountMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearingAccountMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecipientAddresses) > 0 {
		for iNdEx := len(m.RecipientAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientAddresses[iNdEx])
			copy(dAtA[i:], m.RecipientAddresses[iNdEx])
			i = encodeVarintDistribution(dAtA, i, uint64(len(m.RecipientAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClearingAccount) > 0 {
		i -= len(m.ClearingAccount)
		copy(dAtA[i:], m.ClearingAccount)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.ClearingAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearingAccountAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearingAccountAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearingAccountAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDistribution(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClearingAccount) > 0 {
		i -= len(m.ClearingAccount)
		copy(dAtA[i:], m.ClearingAccount)
		i = encodeVarintDistribution(dAtA, i, uint64(len(m.ClearingAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduledDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduledDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduledDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDistribution(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintDistribution(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDistribution(dAtA []byte, offset int, v uint64) int {
	offset -= sovDistribution(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClearingAccountMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClearingAccount)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	if len(m.RecipientAddresses) > 0 {
		for _, s := range m.RecipientAddresses {
			l = len(s)
			n += 1 + l + sovDistribution(uint64(l))
		}
	}
	return n
}

func (m *ClearingAccountAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClearingAccount)
	if l > 0 {
		n += 1 + l + sovDistribution(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovDistribution(uint64(l))
	return n
}

func (m *ScheduledDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovDistribution(uint64(m.Timestamp))
	}
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovDistribution(uint64(l))
		}
	}
	return n
}

func sovDistribution(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDistribution(x uint64) (n int) {
	return sovDistribution(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClearingAccountMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearingAccountMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearingAccountMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientAddresses = append(m.RecipientAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearingAccountAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearingAccountAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearingAccountAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduledDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduledDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduledDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDistribution
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDistribution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, ClearingAccountAllocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDistribution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDistribution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDistribution(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDistribution
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDistribution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDistribution
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDistribution
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDistribution
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDistribution        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDistribution          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDistribution = fmt.Errorf("proto: unexpected end of group")
)
